---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# surveytidy

<!-- badges: start -->
[![R-CMD-check](https://github.com/JDenn0514/surveytidy/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/JDenn0514/surveytidy/actions/workflows/R-CMD-check.yaml)
[![Codecov test coverage](https://codecov.io/gh/JDenn0514/surveytidy/branch/main/graph/badge.svg)](https://codecov.io/gh/JDenn0514/surveytidy)
<!-- badges: end -->

surveytidy provides dplyr and tidyr verbs for survey design objects created
with the [surveycore](https://github.com/JDenn0514/surveycore) package.
It makes survey analysis feel natural to tidyverse users:

```{r}
library(surveycore)
library(dplyr)
library(surveytidy)

# Build a survey design from the 2025 Pew NPORS survey
d <- as_survey(pew_npors_2025, weights = weight, strata = stratum)

# Use familiar dplyr verbs — survey design is preserved automatically
young_adults <- d |>
  # use filter to perform domain estimation (18–29 year olds)
  filter(agecat == 1) |>
  # keep only the columns of interest
  select(agecat, gender, partysum, fin_sit) |>
  # group by gender
  group_by(gender) |>
  # flag respondents reporting financial difficulty
  mutate(struggling = as.integer(fin_sit >= 3))
```

## Key idea: `filter()` marks rows, never removes them

The most important statistical feature of surveytidy is that `filter()` uses
**domain estimation** rather than physical subsetting:

```{r}
# This keeps all 5,022 rows — variance estimation stays correct
republicans <- d |> filter(partysum == 1)
nrow(republicans@data) #> 5022

# This physically removes rows — variance estimates would be wrong
wrong <- subset(d, partysum == 1) # issues a warning
```

When you call `filter()`, surveytidy writes a logical column
`..surveycore_domain..` to the data. Phase 1 estimation functions read this
column to restrict calculations to the domain while retaining all rows for
correct variance estimation. Simply put, this calculates the variance for
subpopulations correctly.

## Installation

```{r, eval = FALSE}
# install.packages("pak")
# install surveycore first, to create surveycore style survey objects
pak::pak("JDenn0514/surveycore")
# install surveytidy
pak::pak("JDenn0514/surveytidy")
```

## Usage

### Filtering (domain estimation)

```{r}
# Single condition
republicans <- d |> filter(partysum == 1)

# Chained filters AND the conditions together
rep_women <- d |>
  filter(partysum == 1) |>
  filter(gender == 2)

# Equivalent — both produce identical domain columns
rep_women2 <- d |> filter(partysum == 1, gender == 2)
```

### Selecting columns

```{r}
# Design variables (weights, strata) are always kept in @data
# even when not selected — they are required for variance estimation
d2 <- select(d, party, gender, agecat, cregion)

# Design variables are hidden from print() but still present in @data
print(d2)
```

### Mutating

```{r}
# Add new columns
d |>
  mutate(
    economy_poor = as.integer(econ1mod >= 3),
    south = as.integer(cregion == 3)
  )

# Modifying a design variable warns you
d |> mutate(weight = weight * 0.5)
#> Warning: mutate() modified design variable(s): `weight`

# Grouped mutate via group_by()
d |>
  group_by(partysum) |>
  mutate(econ_rank = rank(econ1mod) / n())
```

### Renaming

```{r}
# @variables and @metadata stay in sync automatically
d |>
  rename(
    party_affiliation = partysum,
    age_group = agecat
  )
```

### Sorting

```{r}
# Rows sort; domain column moves with them
d |>
  filter(partysum == 1) |>
  arrange(agecat)

# Sort by group first, then by value within group
d |>
  group_by(partysum) |>
  arrange(agecat, .by_group = TRUE)
```

### Grouping

```{r}
d2 <- group_by(d, partysum) # set groups
d3 <- group_by(d2, gender, .add = TRUE) # add to groups
d4 <- ungroup(d3) # remove all groups
```

### Physical row operations (use sparingly)

```{r}
library(tidyr)
# These physically remove rows and always issue a warning.
# Use filter() instead for subpopulation analyses.
slice_head(d, n = 100) # first 100 rows
drop_na(d, fin_sit) # remove rows with NA in fin_sit
```

## Relationship to surveycore

surveytidy is an add-on layer. surveycore provides:

- S7 survey design classes (`survey_taylor`, `survey_replicate`, `survey_twophase`)
- Constructors (`as_survey()`, `as_survey_rep()`, `as_survey_twophase()`)
- Metadata system (variable labels, value labels, question prefaces)

surveytidy provides the dplyr/tidyr interface on top of those classes. Phase 1
(in development) will add estimation functions (`get_mean()`, `get_total()`,
etc.) that respect the domain column and `@groups` set by surveytidy verbs.

## License

GPL-3
