% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter.R
\name{filter.survey_base}
\alias{filter.survey_base}
\alias{filter_out.survey_base}
\title{Keep or drop rows using domain estimation}
\usage{
filter.survey_base(.data, ..., .by = NULL, .preserve = FALSE)

filter_out.survey_base(.data, ..., .by = NULL, .preserve = FALSE)
}
\arguments{
\item{.data}{A \code{\link[surveycore:survey_base]{survey_base}} object.}

\item{...}{<\code{\link[rlang:args_data_masking]{data-masking}}> Logical conditions
evaluated against the survey data. Multiple conditions are combined with
\code{&}. \code{NA} results are treated as \code{FALSE}.}

\item{.by}{Not supported for survey objects. Use \code{\link[=group_by]{group_by()}} to add
grouping.}

\item{.preserve}{Ignored. Included for compatibility with the dplyr generic.}
}
\value{
An object of the same type as \code{.data} with the following properties:
\itemize{
\item All rows appear in the output.
\item Domain status of each row may be updated.
\item Columns are not modified.
\item Groups are not modified.
\item Survey design attributes are preserved.
}
}
\description{
\code{filter()} and \code{filter_out()} mark rows as in or out of the survey domain
without removing them. Unlike a standard data frame filter, all rows are
always retained — only their domain status changes. Estimation functions
restrict analysis to in-domain rows while using the full design for
variance estimation.

\code{filter()} marks rows \strong{matching} the condition as in-domain.
\code{filter_out()} marks rows \strong{matching} the condition as out-of-domain — it
is the complement of \code{filter()}, and reads more naturally when the intent
is exclusion.
}
\details{
\subsection{Chaining}{

Multiple calls accumulate via AND: a row must satisfy every condition to
remain in-domain. These are equivalent:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{filter(d, ridageyr >= 18, riagendr == 2)
filter(d, ridageyr >= 18) |> filter(riagendr == 2)
}\if{html}{\out{</div>}}
}

\subsection{Missing values}{

Unlike base \code{[}, both functions treat \code{NA} as \code{FALSE}: rows where the
condition evaluates to \code{NA} are treated as out-of-domain.
}

\subsection{Useful filter functions}{
\itemize{
\item Comparisons: \code{==}, \code{>}, \code{>=}, \code{<}, \code{<=}, \code{!=}
\item Logical: \code{&}, \code{|}, \code{!}, \code{\link[=xor]{xor()}}
\item Missing values: \code{\link[=is.na]{is.na()}}
\item Range: \code{\link[dplyr:between]{dplyr::between()}}, \code{\link[dplyr:near]{dplyr::near()}}
\item Multi-column: \code{\link[dplyr:across]{dplyr::if_any()}}, \code{\link[dplyr:across]{dplyr::if_all()}}
}
}

\subsection{Inspecting the domain}{

The domain status of each row is stored in the \code{..surveycore_domain..}
column of \verb{@data}. \code{TRUE} means in-domain; \code{FALSE} means out-of-domain.
}
}
\examples{
library(surveytidy)
library(surveycore)
d <- as_survey(pew_npors_2025, weights = weight, strata = stratum)

# Keep adults 50 and older
filter(d, agecat >= 3)

# Multiple conditions are AND-ed together
filter(d, agecat >= 3, gender == 2)

# filter_out() excludes matching rows — complement of filter()
filter_out(d, agecat == 1)

# Chained calls accumulate (these are equivalent)
filter(d, agecat >= 3, gender == 2)
filter(d, agecat >= 3) |> filter(gender == 2)

# Multi-column conditions with if_any() and if_all()
filter(d, dplyr::if_any(c(smuse_fb, smuse_yt), ~ !is.na(.x)))
filter(d, dplyr::if_all(c(smuse_fb, smuse_yt), ~ !is.na(.x)))

}
\seealso{
\code{\link[=filter_out]{filter_out()}} for excluding rows, \code{\link[=subset]{subset()}} for physical row
removal
}
\concept{filtering}
