% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/01-filter.R
\name{filter.survey_base}
\alias{filter.survey_base}
\alias{subset.survey_base}
\title{Filter survey data using domain estimation}
\usage{
\method{filter}{survey_base}(.data, ..., .by = NULL, .preserve = FALSE)

\method{subset}{survey_base}(x, condition, ...)
}
\arguments{
\item{.data}{A \code{survey_taylor}, \code{survey_replicate}, or \code{survey_twophase}
object created by \code{\link[surveycore:as_survey]{surveycore::as_survey()}}.}

\item{...}{Ignored (for compatibility with the base \code{subset()} signature).}

\item{.by}{Not supported for survey objects. Use \code{\link[dplyr:group_by]{dplyr::group_by()}} instead.}

\item{.preserve}{Ignored (included for compatibility with the dplyr
generic signature).}

\item{x}{A survey design object.}

\item{condition}{A logical expression evaluated against \code{x@data}.}
}
\value{
The survey object with an updated \code{..surveycore_domain..} column in
\verb{@data}. Row count is \strong{unchanged}.

A survey object of the same class with only matching rows retained.
}
\description{
Mark rows as in-domain without removing them. Unlike \code{base::subset()} or a
plain data-frame filter, \code{filter()} \strong{never removes rows} from the survey
object. Instead it writes a logical column \code{..surveycore_domain..} to
\verb{@data}. Variance estimation therefore uses all rows — the full design is
intact — while analysis is restricted to the domain.

Chained \code{filter()} calls AND their conditions together:
\code{filter(d, A) |> filter(d, B)} is identical to \code{filter(d, A, B)}.

Physically removes rows from the survey data where \code{condition} evaluates
to \code{FALSE}. Unlike \code{\link[dplyr:filter]{dplyr::filter()}}, this changes the underlying design and can
bias variance estimates.
}
\details{
For subpopulation analyses, use \code{\link[dplyr:filter]{dplyr::filter()}} instead. Only use \code{subset()}
when you have explicitly built the survey design for the subset population.
}
\section{Functions}{
\itemize{
\item \code{subset(survey_base)}: Physically remove rows (use sparingly).
Always issues \code{surveycore_warning_physical_subset}. Prefer \code{filter()} for
subpopulation analyses.

}}
\section{Domain estimation vs. physical subsetting}{

\code{filter()} is the correct tool for subpopulation analyses. Physically
removing rows (via \code{base::subset()}, \code{\link[=subset]{subset()}}, or \code{\link[dplyr:slice]{dplyr::slice()}}) changes
which units contribute to variance estimation and yields incorrect standard
errors. See Thomas Lumley's note for details:
\url{https://notstatschat.rbind.io/2021/07/22/subsets-and-subpopulations-in-survey-inference}
}

\examples{
library(dplyr)
df <- data.frame(y = rnorm(100), x = runif(100),
                 wt = runif(100, 1, 5), g = sample(c("A","B"), 100, TRUE))
d  <- surveycore::as_survey(df, weights = wt)

# Single condition
d_pos <- filter(d, y > 0)

# Multiple conditions (AND-ed)
d_sub <- filter(d, y > 0, g == "A")

# Chained filters produce the same domain column
d_chain <- filter(d, y > 0) |> filter(g == "A")
identical(d_sub@data[[surveycore::SURVEYCORE_DOMAIN_COL]],
          d_chain@data[[surveycore::SURVEYCORE_DOMAIN_COL]])

}
\seealso{
\code{\link[=subset]{subset()}} for physical row removal (with a warning)
}
\concept{filtering}
