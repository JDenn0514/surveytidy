% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group-by.R
\name{group_by.survey_base}
\alias{group_by.survey_base}
\alias{ungroup.survey_base}
\title{Group and ungroup a survey design object}
\usage{
group_by.survey_base(
  .data,
  ...,
  .add = FALSE,
  .drop = dplyr::group_by_drop_default(.data)
)

ungroup.survey_base(x, ...)
}
\arguments{
\item{.data}{A \code{\link[surveycore:survey_base]{survey_base}} object.}

\item{...}{<\code{\link[rlang:args_data_masking]{data-masking}}> For \code{group_by()}:
columns to group by. Computed expressions (e.g.,
\code{cut(ridageyr, breaks = c(0, 18, 65, Inf))}) are supported. For
\code{ungroup()}: columns to remove from the current grouping. Omit to
remove all groups.}

\item{.add}{When \code{FALSE} (default), replaces existing groups. Use
\code{.add = TRUE} to add to the current grouping instead.}

\item{.drop}{Accepted for compatibility with the dplyr interface; has no
effect on survey design objects.}

\item{x}{A \code{\link[surveycore:survey_base]{survey_base}} object (for
\code{ungroup()} and \code{group_vars()}).}
}
\value{
An object of the same type as the input with the following properties:
\itemize{
\item Rows, columns, and survey design attributes are unchanged.
\item For \code{group_by()}: grouping columns are set or updated; rowwise keys
are cleared.
\item For \code{ungroup()}: all or specified grouping columns are removed; rowwise
keys are cleared on full ungroup only.
\item For \code{group_vars()}: a character vector of current grouping column names.
}
}
\description{
\code{group_by()} stores grouping columns on the survey object for use in
grouped operations like \code{\link[=mutate]{mutate()}}. \code{ungroup()} removes the grouping.
\code{group_vars()} returns the current grouping column names.

Unlike dplyr, groups are not attached to the underlying data frame —
they are stored on the survey object itself and applied when needed by
verbs that support grouping.
}
\details{
\subsection{Grouped operations}{

After calling \code{group_by()}, \code{\link[=mutate]{mutate()}} computes within groups. Future
estimation functions will also use grouping to perform stratified analysis.
}

\subsection{Adding to existing groups}{

By default, \code{group_by()} replaces existing groups. Use \code{.add = TRUE} to
append to the current grouping instead.
}

\subsection{Rowwise mode and group_by()}{

\code{group_by(.add = FALSE)} (the default) exits rowwise mode — it clears
\verb{@variables$rowwise} and \verb{@variables$rowwise_id_cols}. \code{group_by(.add = TRUE)} when the design is rowwise promotes the rowwise id columns to
\verb{@groups}, appends the new groups, then clears rowwise mode — mirroring
dplyr's behaviour exactly.
}

\subsection{Partial ungroup}{

\code{ungroup()} with no arguments removes all groups and exits rowwise mode.
With column arguments, it removes only the specified columns from the
grouping — rowwise mode is \strong{not} affected.
}
}
\examples{
library(surveytidy)
library(surveycore)
library(dplyr)
d <- as_survey(pew_npors_2025, weights = weight, strata = stratum)

# Group by a column
group_by(d, gender)

# Grouped mutate — within-group mean centring
d |>
  group_by(gender) |>
  mutate(econ_centred = econ1mod - mean(econ1mod, na.rm = TRUE))

# Add a second grouping variable with .add = TRUE
d |>
  group_by(gender) |>
  group_by(cregion, .add = TRUE)

# Remove all groups
d |> group_by(gender) |> ungroup()

# Partial ungroup — remove only gender, keep cregion
d |>
  group_by(gender, cregion) |>
  ungroup(gender)

# Get current grouping column names
d |> group_by(gender, cregion) |> group_vars()

}
\seealso{
Other grouping: 
\code{\link{is_grouped}()},
\code{\link{is_rowwise}()},
\code{\link{rowwise.survey_base}()}
}
\concept{grouping}
