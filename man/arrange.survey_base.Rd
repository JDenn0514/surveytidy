% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/05-arrange.R
\name{arrange.survey_base}
\alias{arrange.survey_base}
\alias{slice.survey_base}
\alias{slice_head.survey_base}
\alias{slice_tail.survey_base}
\alias{slice_min.survey_base}
\alias{slice_max.survey_base}
\alias{slice_sample.survey_base}
\title{Sort rows and physically select rows of a survey design object}
\usage{
\method{arrange}{survey_base}(.data, ..., .by_group = FALSE)

\method{slice}{survey_base}(.data, ...)

\method{slice_head}{survey_base}(.data, ...)

\method{slice_tail}{survey_base}(.data, ...)

\method{slice_min}{survey_base}(.data, ...)

\method{slice_max}{survey_base}(.data, ...)

\method{slice_sample}{survey_base}(.data, ...)
}
\arguments{
\item{.data}{A survey design object.}

\item{...}{For \code{arrange()}: <\code{\link[rlang:args_data_masking]{data-masking}}>
variables or expressions to sort by. For \verb{slice_*()}: passed to the
corresponding \verb{dplyr::slice_*()} function.}

\item{.by_group}{Logical. If \code{TRUE} and \verb{@groups} is set, rows are sorted
by the grouping variables first, then by \code{...}.}
}
\value{
The survey object with rows reordered (\code{arrange()}) or a physical
subset of rows (\verb{slice_*()}).
}
\description{
\itemize{
\item \code{arrange()} sorts rows in \verb{@data}. The domain column moves with the rows â€”
no update to \verb{@variables$domain} is needed. Supports \code{.by_group = TRUE}
using \verb{@groups} set by \code{\link[dplyr:group_by]{dplyr::group_by()}}.
\item \code{slice()}, \code{slice_head()}, \code{slice_tail()}, \code{slice_min()}, \code{slice_max()},
and \code{slice_sample()} \strong{physically remove rows} and always issue
\code{surveycore_warning_physical_subset}. They error if the result would have
0 rows. Prefer \code{\link[dplyr:filter]{dplyr::filter()}} for subpopulation analyses.
\item \code{slice_sample(weight_by = )} additionally warns with
\code{surveytidy_warning_slice_sample_weight_by} because the \code{weight_by}
column is independent of the survey design weights.
}
}
\section{Functions}{
\itemize{
\item \code{slice(survey_base)}: Select rows by position.

\item \code{slice_head(survey_base)}: Select first \code{n} rows.

\item \code{slice_tail(survey_base)}: Select last \code{n} rows.

\item \code{slice_min(survey_base)}: Select rows with the smallest values.

\item \code{slice_max(survey_base)}: Select rows with the largest values.

\item \code{slice_sample(survey_base)}: Randomly sample rows.

}}
\examples{
library(dplyr)
df <- data.frame(y = rnorm(100), wt = runif(100, 1, 5),
                 g = sample(c("A","B"), 100, TRUE))
d  <- surveycore::as_survey(df, weights = wt)

# Sort rows
d2 <- arrange(d, y)
d3 <- arrange(d, desc(y))

# Physical row selection (issues warning)
d4 <- suppressWarnings(slice_head(d, n = 20))

}
\seealso{
\code{\link[dplyr:filter]{dplyr::filter()}} for domain-aware row marking (preferred)

Other row operations: 
\code{\link{drop_na.survey_base}()}
}
\concept{row operations}
